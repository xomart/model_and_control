#ifndef _ARG_MAIN
#define _ARG_MAIN

#include "JouHeader.h"
#include "JouStrings.h"
#include "math.h"
#include "CtrlWord.h" // Управляющие Слова
#include "arg_header.h"
#include "arg_irvi.cpp"
#include "USOData.h"
#include "neptun_main.h"
#include "ssvp_module.h"
#include "SPSHead.h"
#include "ks020_model.h"
#include "bfi_formats.h"
/*
   +----------------------------------+
   |   Модель БЦВК Аргон-16 (11М67)   |
   +----------------------------------+

   Активируется при выдаче команды на включение БЦВК

   +------------------------------------------+
   | N.N. Программа включения акселерометра   |
   +------------------------------------------+
*/

void arg_aks_on (void) {
A2:
if(i==2)
        {
        e3:
        cw_K3[3] = true; // Формирование команды "Включение акселерометра"
        dt = 50;         // Delta t = 50"
        // Япоп = А3 (яч <437>)
        Yz1[9] = 0;      // Снятие заявки с программы
        // Запуск Сч И5 - Масштаб 0,2
        } else i++;
}

void uso_change (bool USO_Array[20][16]){
  if(USO_Booled[3][6]) cw_a2[0]=0; else cw_a2[0]=1;
}

/*
  Ц Е Н Т Р А Л Ь Н Ы Й
  " Д И С П Е Т Ч Е Р "
  Б Ц В К
  +-----------------------+
  |       Б Л О К И       |
  |     Ж Ё С Т К О Й     |
  |   П Р О Г Р А М М Ы   |
  +-----------------------+
  ЖЕСТКИЕ ПРОГРАММЫ:
    - формируют заявки на программы ПУПС, КУРС, ФИНТ, ПОС, КОНТРОЛЬ ПОС;
    - управляют программами БРВИ, ДИСПЛЕЙ, телеметрии (ТМ).
*/

void arg_zrp (){

}

// Операции по РРП
void arg_rrp (){
// M638.u3
if(cw_c2[0]){
        if(cw_a30[1]){
                if(cw_b6[8]=0) { Yz3[3]=1; goto BLOK10;} else goto BLOK10;
                     }  else goto BLOK10;
            } else goto M405;
BLOK10: // Операции по "РРП"
M405:
Yz2[11]=cw_a20[14]; Yz1[6]=cw_a22[6];
if((cw_c2[0]|cw_c6[8])&&cw_a6[8]){
        Yz1[2]=1; // PUPS
        cw_b6[11]=1; // Начало интегрирования УС
                                 }
if((cw_c2[0]|cw_c6[7])&&cw_a6[7]){
        Yz1[14]=1; // ВЦПС
                                 }
// блок пуска временных программ
// на метку М605
if(cw_AC7[4]){
        if(cw_a6[4]) Yz3[1]=1; //PUNO
             } else  Yz3[1]=0;
// блок анализа аварии СКД из СУБК
// на метрку К
// В Диспетчер
}

void HARD_PROG (){ // ЖЕСТКАЯ ПРОГРАММА
L: // Из программы "Обмен с ПНК"
   ych_RrP[10]=0;
   // Опрос регистров релейных команд 1,3-9 УСЗ
   // Запоминание адреса возврата
   // Обращение к программе релейных прерываний
   // B2=[Rг 4,5] B3=[Rг 6,7] B7=[Rг 8] B8=[Rг 3,9]
   // a16[13,14] = b2[13,14]
   if(cw_a7[2]=1){
        cw_b2[14]=0;
        cw_b2[13]=1;
        cw_TA1[6]=1; } else goto MI01;
MI01: // Обрущение к СПП приоткрытия маски
   if(cw_a4[5]&&cw_b2[0]&&cw_b6[11]){
   if((arg_T0.FormatString("hh:nn:ss")+StrToTime("00:00:01"))==arg_T0.FormatString("hh:nn:ss")) {  // T0+1=Tm
        Yz1[13]=1; /* FINT */ } else goto BLOK2;
         } else goto BLOK2;
BLOK2: // Формирование А2, С2, А3, С3, АС7, А8, С8, Т2-Т7
BLOK3: // Операции по командам "БРУ вкл", "СКД вкл" и др. Коррекция А1, А4, А5
//--------------------------------------------
M632:
if(cw_a2[0])arg_rrp(); else arg_zrp();

   brvi_pr=1; // Разрешаем работу БРВИ

} // ЖЁСТКАЯ ПРОГРАММА

void ARG_POS (){
// Программа Ориентации и Стабилизации

}

/*
   +------------------------------------+
   | N.N. СПП выключения датчиков ИКВ   |
   +------------------------------------+
*/

void arg_spp_ikv_off (void) {
cw_K2[2] = true;   // Выключение ИКВ-1
cw_K2[6] = true;   // Выключение ИКВ-2
cw_Y32[2] = false; // Включение ИКВ-1
cw_Y32[3] = false; // Включение ИКВ-2
// В основную программу <001>
}

/*
   +------------------------------------+
   | N.N. Подпрограмма вывода на ИРВИ   |
   +------------------------------------+
*/

void SetItvi (byte Mode, unsigned short Addr, unsigned short value, char z) {
AnsiString tLe;
	//irvi_string.SubString(1,2) = IntToStr(Mode).SubString(1,1);
	//irvi_string.SubString(3,5) = IntToStr(Addr);
	//irvi_string.SubString(8,7) = "1234567";//IntToStr(value);
	//irvi_string.SubString(15,1) = z;
        irvi_string = "";
        int ale = 5 - IntToStr(Addr).Length();
      //  for(int a; a = ale; a++) {
        tLe.Insert("000",1);     // }
        tLe.Insert(IntToStr(Addr),0);
        JPS(1,"","","",tLe);
        irvi_string.Insert(IntToStr(Mode).SubString(1,1),1);
        irvi_string.Insert(IntToStr(Addr),3);
        irvi_string.Insert(IntToStr(value),8);
        irvi_string.Insert(z,15);
}

void AltSetIrvi(AnsiString Mode, AnsiString Addr, AnsiString value, AnsiString z){
        irvi_string = "";
 	irvi_string.Insert(Mode,0);
	irvi_string.Insert(Addr,3);
	irvi_string.Insert(value,8);
	irvi_string.Insert(z,15);
}

void SetValueToIrvi(){
        irvi_tstring.SubString(8,7) = "432";
}

/*
   +---------------------------------------------------------------+
   | B.    О Р Г А Н И З А Ц И Я   А В Т О М А Т И Ч Е С К О Г О   |
   | К О Н Т У Р А   У П Р А В Л Е Н И Я   О Р И Е Н Т А Ц И Е Й   |
   +---------------------------------------------------------------+
*/

void ku_podgot (void) {
// +----------------+
// +-- 63 секунды --+
// +----------------+
// Подготовка БДУС-1
// Формируем команду "Включение электроники БДУС-1" выбранного комплекта;
// Через 0,6 сек анализируем наличие квитанции о включении питания;
// При наличии квитанции и разрешенном тесте БДУС-1 - ЧЭ БДУС в среднее положение
// задержка 2,4 секунды (тесты БДУС которые стоит описывать только при вводе НшС)
// задержка 60 секунд реализуем Контур Управления
// Если cw_b1[9] = 1, то +0,6 сек к задержке

}

// Программа динамического контура управления ориентацией
void DKUO (void) {

}

//+---------------------+
//    Программы БРВИ
//+---------------------+

// Вынести на редактирование и доработку, что бы в зависимости от 

void mode_31 (int addr, int val){
switch (addr) {   // Обработчик режима
        case 40: cw_b1[val]=1; break;
        case 47: cw_b6[val]=1; break;
        case 50: cw_b10[val]=1; break;
        case 100: cw_r1[val]=1; break;
        case 107: cw_r6[val]=1; break;
        case 274: cw_r17[val]=1; break;
        case 110: cw_a20[val]=1; break;
        case 111: cw_a21[val]=1; break;
        case 112: cw_a22[val]=1; break;
        case 246: cw_a30[val]=1; break;
        case 250: cw_a35[val]=1; break;
        case 277: cw_a19[val]=1; break;
        default: JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Нет такой буквы!",""); break; } }

void mode_30 (int addr, int val){
switch (addr) {   // Обработчик режима
        case 40: cw_b1[val]=0; break;
        case 47: cw_b6[val]=0; break;
        case 50: cw_b10[val]=0; break;
        case 100: cw_r1[val]=0; break;
        case 107: cw_r6[val]=0; break;
        case 110: cw_a20[val]=0; break;
        case 111: cw_a21[val]=0; break;
        case 112: cw_a22[val]=0; break;
        case 246: cw_a30[val]=0; break;
        case 250: cw_a35[val]=0; break;
        case 277: cw_a19[val]=0; break;
        default: JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Нет такой буквы!",""); break; } }

bool* cwn2addr(int addr){
switch (addr) {
        case 40: return cw_b1; break;
        case 47: return cw_b6; break;
        case 50: return cw_b10; break;
        case 100: return cw_r1; break;
        case 107: return cw_r6; break;
        case 274: return cw_r17; break;
        case 460: return cw_a1; break;
        case 51: return cw_a2; break;
        case 464: return cw_a3; break;
        case 53: return cw_a4; break;
        case 54: return cw_a5; break;
        case 55: return cw_a8; break;
        case 470: return cw_a9; break;
        case 471: return cw_a10; break;
        case 472: return cw_a11; break;
        case 473: return cw_a12; break;
        case 474: return cw_a13; break;
        case 271: return cw_a14; break;
        case 272: return cw_a16; break;
        case 275: return cw_a18; break;
        case 227: return cw_a19; break;
        case 110: return cw_a20; break;
        case 111: return cw_a21; break;
        case 112: return cw_a22; break;
        case 270: return cw_a23; break;
        case 766: return cw_a24; break;
        case 1540: return cw_a25; break;
        case 1541: return cw_a26; break;
        case 266: return cw_a27; break;
        case 267: return cw_a28; break;
        case 246: return cw_a30; break;
        case 1542: return cw_a34; break;
        case 250: return cw_a35; break;
        case 461: return cw_c1; break;
        case 463: return cw_c2; break;
        case 465: return cw_c3; break;
        case 467: return cw_c6; break;
        case 462: return cw_c8; break;
        case 475: return cw_c10; break;
        case 273: return cw_x17; break;

        default: JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Ошибка ИРВИ",""); break;
}
}

unsigned long boolArrayToBinary(const bool cw[], size_t size) {
    unsigned long binary = 0;
    for (size_t i = 0; i < size; ++i) {
        binary |= (cw[i] << (size - 1 - i));
    }
    return binary;
}

AnsiString binaryToOctal(unsigned long binary) {
    AnsiString octal = "";
    unsigned long remainder;

    while (binary > 0) {
        remainder = binary % 8;
        octal = IntToStr(remainder) + octal;
        binary /= 8;
    }

    return octal;
}

AnsiString boolcwtostring(const bool cw[]) {
    unsigned long binary = boolArrayToBinary(cw, 16);
    if(binaryToOctal(binary).IsEmpty()) return "000000"; else
    return binaryToOctal(binary);
}

void showvalueirvi(AnsiString val){
irvi_string.SubString(1,1);
irvi_string.SubString(2,1);
irvi_string.SubString(3,1);
irvi_string.SubString(4,1);
irvi_string.SubString(5,1);
irvi_string.SubString(6,1);
irvi_string.SubString(7,1);
irvi_string.SubString(8,1);
irvi_string.SubString(9,1);
irvi_string.SubString(10,1);
irvi_string.SubString(11,1);
irvi_string.SubString(12,1);
irvi_string.SubString(13,1);
irvi_string.SubString(14,1);
irvi_string.SubString(15,1);
}

/*
   +--------------------------------------------+
   | N.N. Подпрограмма проверки значения ИРВИ   |
   +--------------------------------------------+
*/

void ChekIrvi (AnsiString irvi_str){
if(irvi_str.IsEmpty())JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Пустой ввод!",""); else {

irvi_type.mode = StrToInt(irvi_str.SubString(1,2)); // Вырезаем первые два символа строки ирви "режим"
switch (irvi_type.mode) {   // Обработчик режима
        case 00: /* Приоритетный или принудительный режим выдачи пр-м 1 - 4 */
                 break;
        case 04: /* Динамический вывод 10-х чисел */ break;
        case 05: /* Динамический вывод 8-х чисел */ break;
        case 10: /* Ввод уставки РУС */   break;           // Arg addr RUS AUS data?
        case 11: /* Ввод уставки АУС 1-й группы */  break;
        case 12: /* Ввод уставки АУС 2-й группы */  break;
        case 14: /* Одиночный ввод 10-х чисел */                       // Если режим 14, то
                 if((irvi_str.SubString(3,5)).IsEmpty())JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Пустой адрес!",""); else {
                 irvi_type.addr = StrToInt(irvi_str.SubString(3,5));   // Присваиваем значение адреса
                 if(CorrectAddr(irvi_type.addr)) {                     // Проверяем корректность адреса, если корректен, то
                 if((irvi_str.SubString(8,7)).IsEmpty())JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Пустое число!",""); else {
                 irvi_type.value = StrToInt(irvi_str.SubString(8,7));  // Присваиваем значение
                 ArgonMemoryType[irvi_type.addr] = irvi_type.value;    // Записываем его в ячейку памяти Аргона
                 AltSetIrvi(irvi_str.SubString(1,2),irvi_str.SubString(3,5),FormatFloat("00000  ",ArgonMemoryType[irvi_type.addr]),irvi_type.z);
                 //tItvi(irvi_type.mode,irvi_type.addr,ArgonMemoryType[irvi_type.addr], irvi_type.z );   // Выставляем результат на ИРВИ
                 JPS(4,is_argon,is_irvi,"Запись числа "+               // Логируем результат (от имени Аргона)
                 IntToStr(irvi_type.value)+" по адресу "+IntToStr(irvi_type.addr),"");}}
                 else {                                                 // Если адрес не корректен ,то
                 irvi_err = true;
                 JPS(3,is_argon,is_operator,arg_addr_error,"");     } }  // Логируем превышение допустимого значения памяти А16
                 break;
        case 15: /* Одиночный ввод 8-х чисел */
                 irvi_type.addr = StrToInt(irvi_str.SubString(3,5));
                 if(CorrectAddr(irvi_type.addr)) {
                 irvi_type.value = StrToInt(irvi_str.SubString(8,7));  // Присваиваем значение
                 ArgonMemoryType[irvi_type.addr] = irvi_type.value;
                 } else  {                                               // Если адрес не корректен ,то
                 irvi_err = true;
                 JPS(3,is_argon,is_operator,arg_addr_error,"");   }
                  break;
        case 17: /* Групповой ввод 10-х чисел */ break;
        case 18: /* Групповой ввод 8-х чисел */
                // irvi_type.addr = StrToInt(irvi_str.SubString(3,5));   // Присваиваем значение адреса
                 // if(CorrectAddr(irvi_type.addr)) {                    // Проверяем корректность адреса, если корректен, то
                 //irvi_type.value = StrToInt(irvi_str.SubString(8,7));  // Присваиваем значение
                // ArgonMemoryType[irvi_type.addr] = irvi_type.value;   // Записываем его в ячейку памяти Аргона
                 //SetItvi(irvi_type.mode,(irvi_type.addr)+1,ArgonMemoryType[irvi_type.addr], irvi_type.z );   // Выставляем результат на ИРВИ
                 //mode18act=true;
                 break;
        case 21: /* Вывод уставки АУС 1-й группы */
                 //An
                 AltSetIrvi("21","     ","1234567"," ");
                 break;
        case 22: /* Вывод уставки АУС 2-й группы */ break;
        case 24: /* Одиночный вывод 10-х чисел */                      // Если режим 24, то
                 irvi_type.addr = StrToInt(irvi_str.SubString(3,5));   // Присваиваем значение адреса временной переменной
                 if(CorrectAddr(irvi_type.addr)) {                     // Проверяем корректность адреса, если корректен, то
                 SetItvi(irvi_type.mode,irvi_type.addr,ArgonMemoryType[irvi_type.addr], irvi_type.z ); }  // Выставляем результат на ИРВИ
                 else   {                                               // Если адрес не корректен ,то
                 irvi_err = true;
                 JPS(3,is_argon,is_operator,arg_addr_error,"");   }     // Логируем превышение допустимого значения памяти А16
                 break;
        case 25: /* Одиночный вывод 8-х чисел */
                 irvi_type.addr = StrToInt(irvi_str.SubString(3,5));   // Присваиваем значение адреса временной переменной
                 if(CorrectAddr(irvi_type.addr)) {                     // Проверяем корректность адреса, если корректен, то
                 //irvi_type.value = StrToInt();
                 //AltSetIrvi(irvi_type.mode,irvi_type.addr,"5647765", irvi_type.z );    // Выставляем результат на ИРВИ
                 AnsiString valt = boolcwtostring(cwn2addr(irvi_type.addr));
                 //ArgonMemoryType[irvi_type.addr] = StrToInt(valt);
                 valt.Insert(" ",0);
                 AltSetIrvi(irvi_str.SubString(1,2),irvi_str.SubString(3,5),valt, irvi_type.z );
                 JPS(1,IntToStr(irvi_type.mode),IntToStr(irvi_type.addr),IntToStr(irvi_type.value),irvi_type.mode);
                 }   else   {                                               // Если адрес не корректен ,то
                 irvi_err = true;
                 JPS(3,is_argon,is_operator,arg_addr_error,"");   }     // Логируем превышение допустимого значения памяти А16
                 break;
        case 27: /* Групповой вывод 10-х чисел */ break;
        case 28: /* Групповой вывод 8-х чисел  */break;
        case 30: /* Изменение состояния признака в слове - запись единицы */
                 irvi_type.addr = StrToInt(irvi_str.SubString(3,5));   // Присваиваем значение адреса временной переменной
                 if(CorrectAddr(irvi_type.addr)) {                     // Проверяем корректность адреса, если корректен, то
                 irvi_type.value = StrToInt(irvi_str.SubString(8,7));  // Присваиваем значение
                 mode_30(irvi_type.addr,irvi_type.value); }             // Выставляем результат на ИРВИ
                 else   {                                              // Если адрес не корректен ,то
                 irvi_err = true;
                 JPS(3,is_argon,is_operator,arg_addr_error,"");   }    // Логируем превышение допустимого значения памяти А16
                 break;
        case 31: /* Изменение состояния признака в слове - запись нуля */
                 irvi_type.addr = StrToInt(irvi_str.SubString(3,5));   // Присваиваем значение адреса временной переменной
                 if(CorrectAddr(irvi_type.addr)) {                     // Проверяем корректность адреса, если корректен, то
                 irvi_type.value = StrToInt(irvi_str.SubString(8,7));  // Присваиваем значение
                 mode_31(irvi_type.addr,irvi_type.value); }             // Выставляем результат на ИРВИ
                 else   {                                              // Если адрес не корректен ,то
                 irvi_err = true;
                 JPS(3,is_argon,is_operator,arg_addr_error,"");   }    // Логируем превышение допустимого значения памяти А16
                 break;
        case 40: /*  */ break;
        case 41: /*  */
                 CurDispNum = 1;
                 AltSetIrvi("40","","","");break;
        case 42: /*  */
                 CurDispNum = 2;
                 AltSetIrvi("40","","","");break;
        case 43: /*  */
                 CurDispNum = 3;
                 AltSetIrvi("40","","","");break;
        case 44: /*  */
                 CurDispNum = 4;
                 AltSetIrvi("40","","","");
                 break;
        case 45: /*  */
                 CurDispNum = 5;
                 AltSetIrvi("40","","","");
                 break;
        case 46: /*  */
                 CurDispNum = 6;
                 AltSetIrvi("40","","","");
                 break;
        case 47: /* Отбой программ дисплея */
                 CurDispNum = 8;
                 AltSetIrvi("40","","","");
                 break;
        case 48: /* Сверка времени */ break;
        default: irvi_err = true;       // Флаг ошибки (для индикации на ИРВИ)
                 JPS(3,is_argon,is_irvi,"АА","");        // Логируем ошибку о несуществующием режиме
                 irvi_a = 1;
                 JPS(3,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Несуществующий режим!","");  break;
        //irvi_type.addr = StrToInt(irvi_str.SubString(3,5));
        //irvi_type.value = StrToInt(irvi_str.SubString(8,7));
} }

}

void make_00061(){ // Формирование ячейки текущих аварий
 AnsiString temp = "      ";

}

void block034(){ // Блок формирования ГСО
  if(cw_a7[5]){
    if(cw_c7[5]) {
      cw_a5[1]=0;
      // GoTo A
        } else  // ifcw_c7[5]
        if(cw_c3[15]||cw_c3[7]) {
          cw_a5[1]=1;
          //
                }          l
  } // if cw_a7[5]
}

AnsiString instr_002(bool cw_INST[35]){
if(cw_INST[1])  return "00001"; else
if(cw_INST[2])  return "00010"; else
if(cw_INST[3])  return "00011"; else
if(cw_INST[4])  return "00100"; else
if(cw_INST[5])  return "00101"; else
if(cw_INST[6])  return "00110"; else
if(cw_INST[7])  return "00111"; else
if(cw_INST[8])  return "01000"; else
if(cw_INST[9])  return "01001"; else
if(cw_INST[10]) return "01010"; else
if(cw_INST[11]) return "01011"; else
if(cw_INST[12]) return "01100"; else
//if(cw_INST[13]) return ""; else   // ТАК НАДО
if(cw_INST[14]) return "01110"; else
if(cw_INST[15]) return "01111"; else
//if(cw_INST[16]) return ""; else
//if(cw_INST[17]) return ""; else
//if(cw_INST[18]) return ""; else
//if(cw_INST[19]) return ""; else
//if(cw_INST[20]) return ""; else
if(cw_INST[21]) return "10001"; else
if(cw_INST[22]) return "10010"; else
if(cw_INST[23]) return "10011"; else
if(cw_INST[24]) return "10100"; else
if(cw_INST[25]) return "10101"; else
if(cw_INST[26]) return "10110"; else
if(cw_INST[27]) return "10111"; else
if(cw_INST[28]) return "11000"; else
if(cw_INST[29]) return "11001"; else
//if(cw_INST[30]) return ""; else    // ТАК НАДО
if(cw_INST[31]) return "11011"; else
if(cw_INST[32]) return "11100"; else
if(cw_INST[33]) return "11101"; else
if(cw_INST[34]) return "11110"; else
if(cw_INST[35]) return "11111";

AnsiString temp_instr = "";

}

class JP {

/* void blok_3 () {
if(cw_a7[1]) cw_b1[7]=1;
else {
        if(cw_C7[1]) {
                if(!cw_a14[9]&&!cw_a8[7]) cw_b1[7]=1;
                else
                     }
     }
if(cw_C3[0]&&cw_C3[2])

}; */

void blok_10 () {
cw_b1[11]=1;
cw_a4[0]=0; cw_a4[1]=0; cw_a4[2]=0; cw_a4[3]=0;
cw_a4[4]=0; cw_a4[6]=0; cw_a4[7]=0; cw_a4[8]=0;
cw_a4[9]=0; cw_a4[10]=0; cw_a4[13]=0; cw_a4[14]=0;
cw_a4[15]=0; cw_a9[0-15]=0; cw_a5[0-15]=0; };

};

// test void's
void pres_alarm_st(double SpsPressure){
 if(SpsPressure<401) USO_Booled[9][11]=1;
}

static bool self_test_pr;

int self_test_long () {
 // Проведение самотестирования - длинное
 // тут должен быть алгоритм тестирования
 // Проверяем ОЗУ, ДЗУ, процессор и все устройства обмена (УО-1 - УО-7)
 self_test_pr = 1;
 return 3; }

int self_test_short () { // Проведение самотестирования - короткое
 // тут должен быть алгоритм тестирования
 // Проверяем ОЗУ, ДЗУ, процессор и устройства обмена (УО-1, 2, 4, 5, 6)
 if(USO_Booled[3][13]||
    USO_Booled[3][2]||
    USO_Booled[3][3]||
    USO_Booled[3][4]){
     self_test_pr = 1;
     return 0;
   } else {
  // Признак-возврат отсутствия выбора канала БЦВК провереку к-ро проводить
     self_test_pr = 1;
     JPS(3,is_argon,is_operator,"Пуск не возможен, т.к. нет канала для самопроверки.","");
     return 1; }}

void arg_acc_handler(int Result) {
// Выставляем признаки -  + ЦО +
// Так же выставляем признак Срочной Аварии (в зависимости от результата теста)
USO_Booled[10][1]=1; // "Авария БЦВК" на ТСЭ
USO_Booled[9][7]=1;  // "Авария ДК" (разделять???)
USO_Booled[3][10]=0;
USO_Booled[3][11]=0;
co_priz =1;
arg_work_pr=0;
}



void argon_takt (){
apdp=1;
if(USO_Booled[3][10]){   // Если есть признак питания чайки
apdp=2;
if(!arg_work_pr){        // Если нет признака работы Аргона (состояние самопроверки) - перенести в отдельную функцию
// Проводим самопроверку - self_test.
// Если результат удвлетворительный, выставляем соответствующие признаки
// Добавить самопроверку по каналам АБВ (внутри self_test_)
apdp=3;
   if(sp_d_k==1) {  // Если выбрана длинная самопроверка (1 минута - t), то...
      JPS(1,is_argon,is_operator,"Проведение длинной самопроверки...","");
      if(t==300) tResult = self_test_long(); else t++; } else

   if(sp_d_k==0) {  // Если выбрана короткая самопроверка (5 секунд), то...
      JPS(1,is_argon,is_operator,"Проведение короткой самопроверки...","");
     if(t==25){ tResult=0; apdp=4; self_test_pr=1;} else t++; }

// По окончанию теста считываем результат - если = 0, то тест прошел удачно и тогда
if(self_test_pr) {          // Если есть признак окончания теста
apdp=5;
JPS(1,is_argon,is_operator,"Самопроверка окончена. Значение tResult = "+IntToStr(tResult),"");

        // РЕЗУЛЬТАТ 0
        if(tResult==0){                   // выставляем соответствующие признаки...
         apdp=6;
         USO_Booled[11][6]=true;}         // Выставляем признак БЦВК Готов на ТСЭ

        // РЕЗУЛЬТАТ 1
        else if(tResult==1){              // Если во время теста произошла ошибка (Result != 0), тогда
        JPS(3,is_argon,is_operator,"Самопроверка завершена с ошибкой. Значение tResult = "+IntToStr(tResult),"");
         arg_acc_handler(tResult);        // Вызываем обработчик ошибок Аргона
         argon_ready=false;}       // Прекращаем работу БЦВК

       // ВЕРНЫЙ РЕЗУЛЬТАТ
        if(USO_Booled[11][6]){            // Если есть готовность БЦВК, то...
          apdp=7;
          arg_work_pr = true;             // Признак работы Аргона (по нему происходит запуск)
          USO_Booled[11][7]=true;         // Выставляем "ОСК" для ТСЭ (от кого?)
         //---------//
         // П У Н У //
         // Программа Установки Начальных Условий (ПУНУ) //
         //=======================================//



         }
    apdp=8;

         } //self_test_pr
} else {
apdp=9;

///////////////////////////////////
// ! ! ! ! ! ! ! ! ! ! ! ! ! ! ! //
//   Р А Б О Т А   А Р Г О Н А   //
//  Начало вычислительного такта //
///////////////////////////////////

i_ot_pusk++; // Счетчик тактов БЦВК
// В СУД "Чайка-3" по началу каждого такта происходит самоконтроль (СК) - self_check

// Блок Жесткой программы -

if(cw_a5[2]||cw_a5[3]||cw_a5[6]||cw_a16[0]||cw_a16[2]) cw_a5[1]=1; else cw_a5[1]=0;   // Выставка обобщённого ГСО

// Остальные блоки. СПС
pres_alarm_st(TSpsDataN[19]); // Сверка давления (НЕ ДСД)

//
/*****************************************/
// Б Л О К   И Н Т Е Г Р И Р О В А Н И Я //
// П А Р А М Е Т Р О В   Д В И Ж Е Н И Я //
/*****************************************/
if(i_tok==5){   // ВНИМАНИЕ!!!!
integer_n++;
// Точно каждый такт???
dynamics.rs0 = dynamics.rs;
dynamics.sks0 = dynamics.sks;
dynamics.omy0 = dynamics.omy;
dynamics.omz0 = dynamics.omz;
///////////////////////////////
//                           //
// А. Обслуживание динамики  //
//                           ////////////////////////////////////////////
// Начинать расчет при введенных признаках - (описать список признаков //
/////////////////////////////////////////////////////////////////////////

////////////
// Аварии //
////////////
dynamics.Y2 = pow((2 * dynamics.ax1 * (dynamics.rs - 202)),0.5);

if(dynamics.sks > dynamics.Y2){
//JPS(3,"Диспетчер Аргон-16  -  ","ОПАСНО |V|>9 m/s","","");
}

// Подпрограмма Контроля Расхода (КОРА)
// Контроль расхода на сближение осуществляется только на дальнем уч-ке сбл (признак?).
// Производим постоянное сравнивание распологаемого ресурса (R)
// и прогнозируемого Rп расходов топлива на ориентацию ЦМ в режиме СБ
// если R - Rп < 3,5 кг, то формируем ИН 05 "Нет ресурса для СБ" и вводим
// признак cw_a23[0]=1; "Запрет коррекции". При этом, если по КРЛ ввести новое
// значение уставки BR, то при превышении разности между распологаемым и прогнозируемым
// расходами величины 14 кг запрет коррекции снимается

if(dynamics.rasp < 20){
JPS(3,"Диспетчер Аргон-16  -  ","ДОСТИГНУТ ГО !","","");
}

if(dynamics.rs<=45){ // Складывание 2АО
USO_Booled[1][4]  = true;
}

if(dynamics.rs<=40){ //
        if(KSP_Booled[4][6]=0)KSP_Booled[4][6]=0; else {}
// Д9
// Д13
// Д17
// С11
ssvp_ready=1;
}

/*
+---------+
| КАСАНИЕ |
+---------+
*/
if(dynamics.rs<=0.02){
apdp=10;
//НЕТ КАСАНИЕ! cw_a8[7]=1;  // "СЦЕПКА"
        if(dynamics.Spr<=-0.02) {// Если нет промаха
                prks=1;
                apdp=11;
                JPS(4,is_miu+" ",is_operator.Delete(is_operator.Length(),1),"Есть касание! Начало формирования протокола.","");
                arg_work_pr=0;  }
//rygim=0;
}

if(dynamics.rs<10&&dynamics.sks>1){
JPS(3,"Диспетчер Аргон-16  -  ","Большая скорость на малой дальности!","","");

}

///////////////////////////////////
// Расчет расхода топлива от РУД //
///////////////////////////////////
//                   Линейное ускорение             Боковое по Y                   Боковое по Z
dynamics.rudkg = ((dynamics.ax*0.046/0.01849)+(dynamics.ay*0.046/0.01915)+abs(dynamics.az*0.046/0.01897));

///////////////////////////////////////////
// Расчет расхода топлива от компенсации //
// вращения при боковом перемещении      //
///////////////////////////////////////////
dynamics.kvkg = -((0.209 * 0.046 * dynamics.ay / 0.0383 / 0.621) + (0.209 * 0.046 * dynamics.az / 0.03794 / 0.592));

/////////////////////////////////////////
// Общий расход топлива (на вычитание) //
/////////////////////////////////////////
//              ОБЩ.ТОПЛИВО               РУД              ВпБП            РУО               РУО               РУО
dynamics.rasp = dynamics.rasp - (abs(dynamics.rudkg) + dynamics.kvkg + dynamics.ruokgx + dynamics.ruokgy + dynamics.ruokgz);

////////////////////////////////////////////////////
// Алгоритмы расчета параметров движения с учетом //
// боковых скоростей для заданной траектории.     //
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=//
// Расчет радиальной дальности //  Версия  0.001  //
////////////////////////////////////////////////////
//                      (Дальность по НУ минус время умноженное на скорость по НУ) в квадрате плюс
dynamics.rs = pow((pow((dynamics.rs0 - ht * dynamics.sks0),2) +
              pow((ht * dynamics.rs0 * 0.017453),2) *
              (dynamics.omy0 * dynamics.omy0 + dynamics.omz0 * dynamics.omz0)),0.5);

////////////////////////////////////////////////////
// Расчет радиальной скорости  //  Версия  0.001  //
////////////////////////////////////////////////////
dynamics.sks = ht * (dynamics.axd + dynamics.axruo - dynamics.ax) + (dynamics.rs0 * dynamics.sks0 - ht *
(pow(dynamics.sks0,2) + (pow(dynamics.omy,2) + pow(dynamics.omz,2)) * pow((0.017453 * dynamics.rs0),2))) / dynamics.rs;

///////////////////////////////////////////////
// Расчет угловой скорости линии визирования //
// по горизонтали (ось OY) и по тангажу (OZ) //
///////////////////////////////////////////////
dynamics.omy = dynamics.omy0 * pow((dynamics.rs0 / dynamics.rs),2) + 57.3 * dynamics.az / dynamics.rs;
dynamics.omz = dynamics.omz0 * pow((dynamics.rs0 / dynamics.rs),2) + 57.3 * dynamics.ay / dynamics.rs;

dynamics.omyf = (dynamics.omy * cos(dynamics.uomx * 0.017454) + dynamics.omz * sin(dynamics.uomx * 0.017454));
dynamics.omzf = (dynamics.omz * cos(dynamics.uomx * 0.017454) - dynamics.omy * sin(dynamics.uomx * 0.017454));

dynamics.omzx = (dynamics.omz * cos(dynamics.Ex * 0.017454) + dynamics.omy * sin(dynamics.Ex * 0.017454));
dynamics.omyx = (dynamics.omy * cos(dynamics.Ex * 0.017454) - dynamics.omz * sin(dynamics.Ex * 0.017454));
////////////////////////////
// Дополнительные расчеты //
////////////////////////////
dynamics.V = pow(pow((pow(dynamics.sks, 2) + dynamics.vb),2),0.5);
dynamics.axd = abs(dynamics.ay * 0.157959) + abs(dynamics.az * 0.157924) + abs(dynamics.az * 0.157924) + abs(dynamics.az * 0.157924);

////////////////////
// Расчет промаха //
////////////////////
//                (Омега Z * Ро)*(Омега Z * Ро)  *   ???    /  Вектор скорости
dynamics.ypr = pow(dynamics.omz * dynamics.rs,2) * 0.017453 / dynamics.V;   //  Sy
dynamics.zpr = pow(dynamics.omy * dynamics.rs,2) * 0.017453 / dynamics.V;   //  Sz
dynamics.Spr = dynamics.rs * dynamics.vb / dynamics.V;                      //  S

//Линейный промах = dynamics.rs/sqrt(pow(dynamics.sks/,2)+1)

////////////////////////////
// Расчет времени пролета //
////////////////////////////

t_prolet[0] = abs(dynamics.rs * abs(dynamics.sks)/pow(dynamics.V,2));
t_prolet[1] = t_prolet[0]/86400;


//////////////////////////////
// Расчет боковых скоростей //
//////////////////////////////
dynamics.vby = dynamics.omz * dynamics.rs * 0.017453;
dynamics.vbz = dynamics.omy * dynamics.rs * 0.017453;

//////////////////  25 * 0.9 *
// Расчет углов //
//////////////////

dynamics.uomy = dynamics.uomy + (dynamics.omy + dynamics.Ey); // угол =  1 сек*омега у
dynamics.uomz = dynamics.uomz + (dynamics.omz + dynamics.Ez); // угол  от омеги z + вращение ТПК
dynamics.uomx = dynamics.uomx + dynamics.Ex;                             // угол  от  вращения ТПК

//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*

///////////////////////////////
// Вычисление относительной  //
//   дальности по прогнозу   //
///////////////////////////////

//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*

//////+///////////////////////////////+//////
//=//   Б Л О К   А Л Г О Р Т И М О В   //=//
//+//   А В Т О М А Т И Ч Е С К О Г О   //+//
//=//        У П Р А В Л Е Н И Я        //=//
//////+///////////////////////////////+//////

///////////////////////////////////////////
// Подпрограммы стабилизации и коррекции //
///////////////////////////////////////////
if(argon_auto_contr){
 if(dynamics.omz>0.001) dynamics.Ez = -0.62063 * 0.5; else dynamics.Ez = 0;
}



//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*//*
i_tok = 0;
} else i_tok++; // Что бы интегрирование было с шагом в секунду  ВНИМАНИЕ!!!
// Задача = сделать шаг интегрирования 0.100 мс
// а шаг отображения на форматах (не ИнПУ) так как удобно оператору

if(cw_b1[12]) USO_Booled[12][7]=1; else USO_Booled[12][7]=0;

/* if(cw_b1[12]&&!USO_Booled[3][7]){
if(YzS1[0]&&YzS1[1]==0){ // Если есть заявка на "Присваивание"
 f_test++;
 Label46->Caption="Состояние заявки на присваивание: "+IntToStr(f_test);
 YzS1[1]=1; */
}
}

/////////////////////////////  USO_Booled[1][16] КУРС1
//*************************//  USO_Booled[2][0]  КУРС2
//** РАБОТА С РТС "КУРС" **//
//*************************//
/////////////////////////////
// if(Время бортовое > Т1)
// if(заявка на программу КУРС) (в любом месте?)
// формируем признак cw_b6[6]=1; и выдаем команду на (USO_Booled[2][0]=true; КУРС2) включение невыбранного
// комплекта КУРС, а так же в систему КУРС выдаем команду "вращение"
// на БФИ "КУРС2" "ВРАЩЕН"

//vill_test=1;
// Start integer if I9 and I11 = true
//i_takt++;


///////////////////////////////
// Обработчик ввода признака //
//    ИНДИКАТОРНЫЙ РЕЖИМ     //
///////////////////////////////
if(cw_b1[7]) { // If "IR" true
 // Вводим запрет на формирование управляющих импульсов на ДПО
 // Вводим запрет на формирование ГСО
 // Вводим запрет на контроль расхода топлива
 // Вводим запрет на контроль ориентации в ОСК
 // Вводим запрет на динамический контроль
}

/* Отладочные обработчики признаков
   Перенос в прорамы БЦВК*/
//if(cw_b6[13]) { // "Разрешение причаливания"
// Гасим "ЗАВ КОН" (почему?)
//if(!arg_half_false[1]){
//JPS(4,"ОТЛАДОЧНОЕ: Прошла команда в СУБК \"Причаливание\", запуск процедуры...","","","");
//arg_half_false[1]=true;}
//}

if(USO_Booled[0][0]){  // Check Open SKD S001.1
if(pr_TSKD){ // Если Время.борт = ТСКД  S001
  JPS(4,"ОТЛАДОЧНОЕ: Прошла команда в СУБК \"Включение СКД\", запуск S001.1","","","");
  //arg_du_on_skd();
  pr_TSKD = false;
} // S001
} // S001.1
} // else !arg_work_pr
//} // SUDN Power
//--+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+--
//----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---
//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+----



#endif //_ARG_MAIN

